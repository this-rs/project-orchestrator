name: Release

on:
  push:
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag (e.g. v0.0.1) — must already exist"
        required: true
        type: string

permissions:
  contents: write
  packages: write

env:
  CARGO_TERM_COLOR: always
  BINARY_NAME: orchestrator
  FRONTEND_REPO: this-rs/project-orchestrator-frontend
  # Resolve the release tag: use the workflow_dispatch input if provided, otherwise GITHUB_REF_NAME (from tag push)
  RELEASE_TAG: ${{ inputs.tag || github.ref_name }}

jobs:
  # ==========================================================================
  # Build frontend - Compile React SPA once, share as artifact
  # ==========================================================================
  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    steps:
      - name: Checkout frontend
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FRONTEND_REPO }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Upload frontend dist
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: dist/
          retention-days: 1

  # ==========================================================================
  # Build backend - Compile light + full variants in a single job per target
  # (shares compiled dependencies between the two variants for ~50% faster CI)
  # ==========================================================================
  build-backend:
    name: Build ${{ matrix.target }}
    runs-on: ${{ matrix.runner }}
    needs: [build-frontend]
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS Apple Silicon
          - target: aarch64-apple-darwin
            runner: macos-14
            os: macos
            arch: arm64
            use_cross: false

          # macOS Intel (macos-14 is ARM64 but can cross-compile x86_64)
          - target: x86_64-apple-darwin
            runner: macos-14
            os: macos
            arch: x86_64
            use_cross: false

          # Linux x86_64
          - target: x86_64-unknown-linux-gnu
            runner: ubuntu-latest
            os: linux
            arch: x86_64
            use_cross: true

          # Linux ARM64
          - target: aarch64-unknown-linux-gnu
            runner: ubuntu-latest
            os: linux
            arch: arm64
            use_cross: true

          # Windows x86_64
          - target: x86_64-pc-windows-msvc
            runner: windows-latest
            os: windows
            arch: x86_64
            use_cross: false

    steps:
      - uses: actions/checkout@v4

      - name: Get version from tag
        id: version
        shell: bash
        run: echo "version=${RELEASE_TAG#v}" >> "$GITHUB_OUTPUT"

      - name: Inject version from git tag
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          sed -i.bak "0,/^version = \".*\"/s//version = \"${VERSION}\"/" Cargo.toml
          rm -f Cargo.toml.bak
          echo "Injected version ${VERSION}:"
          grep '^version' Cargo.toml | head -1

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache cargo registry
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "release-${{ matrix.target }}"

      - name: Install cross-rs
        if: matrix.use_cross
        run: cargo install cross --git https://github.com/cross-rs/cross

      # --- Light variant (no embedded frontend) ---

      - name: Build light variant (native)
        if: "!matrix.use_cross"
        run: cargo build --release --target ${{ matrix.target }}

      - name: Build light variant (cross)
        if: matrix.use_cross
        run: cross build --release --target ${{ matrix.target }}

      - name: Package light (Unix)
        if: matrix.os != 'windows'
        shell: bash
        run: |
          ARCHIVE_NAME="${BINARY_NAME}-${{ steps.version.outputs.version }}-${{ matrix.os }}-${{ matrix.arch }}"
          mkdir -p "staging/${ARCHIVE_NAME}"
          for bin in orchestrator orch mcp_server; do
            cp "target/${{ matrix.target }}/release/${bin}" "staging/${ARCHIVE_NAME}/"
          done
          if [ -d "queries" ]; then
            cp -r queries "staging/${ARCHIVE_NAME}/"
          fi
          cd staging
          tar czf "${ARCHIVE_NAME}.tar.gz" "${ARCHIVE_NAME}"
          echo "ARCHIVE_LIGHT=${ARCHIVE_NAME}.tar.gz" >> "$GITHUB_ENV"

      - name: Package light (Windows)
        if: matrix.os == 'windows'
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $archiveName = "${env:BINARY_NAME}-${version}-windows-${{ matrix.arch }}"
          New-Item -ItemType Directory -Force -Path "staging/${archiveName}"
          foreach ($bin in @("orchestrator", "orch", "mcp_server")) {
            Copy-Item "target/${{ matrix.target }}/release/${bin}.exe" "staging/${archiveName}/"
          }
          if (Test-Path "queries") {
            Copy-Item -Recurse "queries" "staging/${archiveName}/"
          }
          Compress-Archive -Path "staging/${archiveName}" -DestinationPath "staging/${archiveName}.zip"
          echo "ARCHIVE_LIGHT=${archiveName}.zip" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Upload light artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARCHIVE_LIGHT }}
          path: staging/${{ env.ARCHIVE_LIGHT }}
          retention-days: 1

      # --- Full variant (with embedded frontend) ---
      # Incremental build: only crates affected by the `embedded-frontend` feature
      # are recompiled (~2 min instead of full ~10 min).

      - name: Download frontend dist
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: dist/

      - name: Build full variant (native)
        if: "!matrix.use_cross"
        run: cargo build --release --features embedded-frontend --target ${{ matrix.target }}

      - name: Build full variant (cross)
        if: matrix.use_cross
        run: cross build --release --features embedded-frontend --target ${{ matrix.target }}

      - name: Package full (Unix)
        if: matrix.os != 'windows'
        shell: bash
        run: |
          ARCHIVE_NAME="${BINARY_NAME}-full-${{ steps.version.outputs.version }}-${{ matrix.os }}-${{ matrix.arch }}"
          mkdir -p "staging/${ARCHIVE_NAME}"
          for bin in orchestrator orch mcp_server; do
            cp "target/${{ matrix.target }}/release/${bin}" "staging/${ARCHIVE_NAME}/"
          done
          if [ -d "queries" ]; then
            cp -r queries "staging/${ARCHIVE_NAME}/"
          fi
          cd staging
          tar czf "${ARCHIVE_NAME}.tar.gz" "${ARCHIVE_NAME}"
          echo "ARCHIVE_FULL=${ARCHIVE_NAME}.tar.gz" >> "$GITHUB_ENV"

      - name: Package full (Windows)
        if: matrix.os == 'windows'
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $archiveName = "${env:BINARY_NAME}-full-${version}-windows-${{ matrix.arch }}"
          New-Item -ItemType Directory -Force -Path "staging/${archiveName}"
          foreach ($bin in @("orchestrator", "orch", "mcp_server")) {
            Copy-Item "target/${{ matrix.target }}/release/${bin}.exe" "staging/${archiveName}/"
          }
          if (Test-Path "queries") {
            Copy-Item -Recurse "queries" "staging/${archiveName}/"
          }
          Compress-Archive -Path "staging/${archiveName}" -DestinationPath "staging/${archiveName}.zip"
          echo "ARCHIVE_FULL=${archiveName}.zip" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Upload full artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARCHIVE_FULL }}
          path: staging/${{ env.ARCHIVE_FULL }}
          retention-days: 1

  # ==========================================================================
  # Package Debian - Build .deb packages for Linux targets
  # ==========================================================================
  package-deb:
    name: Package .deb (${{ matrix.arch }})
    runs-on: ubuntu-latest
    needs: [build-backend]
    if: always()
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            arch: amd64
            artifact_os: linux
            artifact_arch: x86_64

          - target: aarch64-unknown-linux-gnu
            arch: arm64
            artifact_os: linux
            artifact_arch: arm64

    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cargo-deb
        run: cargo install cargo-deb

      - name: Get version from tag
        id: version
        run: echo "version=${RELEASE_TAG#v}" >> "$GITHUB_OUTPUT"

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.BINARY_NAME }}-${{ steps.version.outputs.version }}-${{ matrix.artifact_os }}-${{ matrix.artifact_arch }}.tar.gz
          path: artifact/

      - name: Extract binaries to target dir
        run: |
          ARCHIVE_NAME="${BINARY_NAME}-${{ steps.version.outputs.version }}-${{ matrix.artifact_os }}-${{ matrix.artifact_arch }}"
          tar xzf "artifact/${ARCHIVE_NAME}.tar.gz" -C artifact/
          # cargo-deb --target expects binaries in target/<triple>/release/
          mkdir -p "target/${{ matrix.target }}/release"
          for bin in orchestrator orch mcp_server; do
            cp "artifact/${ARCHIVE_NAME}/${bin}" "target/${{ matrix.target }}/release/${bin}"
          done
          chmod +x target/${{ matrix.target }}/release/*

      - name: Build .deb package
        run: |
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            # Use arm64-cross variant: explicit depends instead of $auto
            # (dpkg-shlibdeps can't resolve ARM64 libs on x86_64 runner)
            cargo deb --no-build --no-strip --variant=arm64-cross --target ${{ matrix.target }}
          else
            cargo deb --no-build --target ${{ matrix.target }}
          fi

      - name: Find and upload .deb
        run: |
          DEB_FILE=$(find target/ -name "*.deb" | head -1)
          DEB_NAME=$(basename "$DEB_FILE")
          cp "$DEB_FILE" "$DEB_NAME"
          echo "DEB_NAME=${DEB_NAME}" >> "$GITHUB_ENV"

      - name: Upload .deb artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.DEB_NAME }}
          path: ${{ env.DEB_NAME }}
          retention-days: 1

  # ==========================================================================
  # Package RPM - Build .rpm packages for Linux targets
  # ==========================================================================
  package-rpm:
    name: Package .rpm (${{ matrix.arch }})
    runs-on: ubuntu-latest
    needs: [build-backend]
    if: always()
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            arch: x86_64
            artifact_os: linux
            artifact_arch: x86_64

          - target: aarch64-unknown-linux-gnu
            arch: aarch64
            artifact_os: linux
            artifact_arch: arm64

    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cargo-generate-rpm
        run: cargo install cargo-generate-rpm

      - name: Get version from tag
        id: version
        run: echo "version=${RELEASE_TAG#v}" >> "$GITHUB_OUTPUT"

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.BINARY_NAME }}-${{ steps.version.outputs.version }}-${{ matrix.artifact_os }}-${{ matrix.artifact_arch }}.tar.gz
          path: artifact/

      - name: Extract binaries to target dir
        run: |
          ARCHIVE_NAME="${BINARY_NAME}-${{ steps.version.outputs.version }}-${{ matrix.artifact_os }}-${{ matrix.artifact_arch }}"
          tar xzf "artifact/${ARCHIVE_NAME}.tar.gz" -C artifact/
          # cargo-generate-rpm --target expects binaries in target/<triple>/release/
          mkdir -p "target/${{ matrix.target }}/release"
          for bin in orchestrator orch mcp_server; do
            cp "artifact/${ARCHIVE_NAME}/${bin}" "target/${{ matrix.target }}/release/${bin}"
          done
          chmod +x target/${{ matrix.target }}/release/*

      - name: Build .rpm package
        run: cargo generate-rpm --target ${{ matrix.target }}

      - name: Find and upload .rpm
        run: |
          RPM_FILE=$(find target/ -name "*.rpm" | head -1)
          RPM_NAME=$(basename "$RPM_FILE")
          cp "$RPM_FILE" "$RPM_NAME"
          echo "RPM_NAME=${RPM_NAME}" >> "$GITHUB_ENV"

      - name: Upload .rpm artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.RPM_NAME }}
          path: ${{ env.RPM_NAME }}
          retention-days: 1

  # ==========================================================================
  # Build Tauri Desktop - Compile signed desktop bundles for all platforms
  # ==========================================================================
  build-tauri:
    name: Tauri ${{ matrix.target }}
    runs-on: ${{ matrix.runner }}
    needs: [build-frontend, build-backend]
    env:
      # Expose secrets as job-level env so step `if:` conditions can check them
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: aarch64-apple-darwin
            runner: macos-14
            tauri_target: aarch64-apple-darwin
            artifact_os: macos
            artifact_arch: arm64

          - target: x86_64-apple-darwin
            runner: macos-14
            tauri_target: x86_64-apple-darwin
            artifact_os: macos
            artifact_arch: x86_64

          - target: x86_64-unknown-linux-gnu
            runner: ubuntu-latest
            tauri_target: x86_64-unknown-linux-gnu
            artifact_os: linux
            artifact_arch: x86_64

          - target: x86_64-pc-windows-msvc
            runner: windows-latest
            tauri_target: x86_64-pc-windows-msvc
            artifact_os: windows
            artifact_arch: x86_64

    steps:
      - uses: actions/checkout@v4

      - name: Get version from tag
        id: version
        shell: bash
        run: echo "version=${RELEASE_TAG#v}" >> "$GITHUB_OUTPUT"

      # Inject the git tag version into all version files so the built
      # artifacts (app name, About dialog, --version flag) match the release.
      - name: Inject version from git tag
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "Injecting version ${VERSION} into project files..."

          # Root Cargo.toml (workspace)
          sed -i.bak "0,/^version = \".*\"/s//version = \"${VERSION}\"/" Cargo.toml
          rm -f Cargo.toml.bak

          # Desktop Tauri Cargo.toml
          sed -i.bak "0,/^version = \".*\"/s//version = \"${VERSION}\"/" desktop/src-tauri/Cargo.toml
          rm -f desktop/src-tauri/Cargo.toml.bak

          # Tauri config JSON
          sed -i.bak "s/\"version\": \"[^\"]*\"/\"version\": \"${VERSION}\"/" desktop/src-tauri/tauri.conf.json
          rm -f desktop/src-tauri/tauri.conf.json.bak

          echo "Verification:"
          grep '^version' Cargo.toml | head -1
          grep '^version' desktop/src-tauri/Cargo.toml | head -1
          grep '"version"' desktop/src-tauri/tauri.conf.json

      - name: Download frontend dist
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: frontend-dist/

      # Replicate scripts/build-desktop.sh logic:
      # 1. Copy dist → desktop/dist/  2. Copy splash.html into dist  3. Build mcp_server  4. cargo tauri build
      - name: Prepare desktop/dist (copy frontend + splash.html)
        shell: bash
        run: |
          rm -rf desktop/dist
          cp -r frontend-dist desktop/dist
          # splash.html must be in desktop/dist/ alongside the frontend assets
          if [ -f "desktop/src-tauri/splash.html" ]; then
            cp desktop/src-tauri/splash.html desktop/dist/splash.html
          fi
          echo "desktop/dist contents:"
          ls -la desktop/dist/

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache cargo registry
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "tauri-${{ matrix.target }}"

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf libssl-dev

      - name: Install Tauri CLI
        run: cargo install tauri-cli --version "^2"

      # Reuse the mcp_server binary already compiled by build-backend
      # (same code, same target, same release profile — no need to compile again)
      - name: Download pre-built mcp_server
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.BINARY_NAME }}-${{ steps.version.outputs.version }}-${{ matrix.artifact_os }}-${{ matrix.artifact_arch }}${{ matrix.artifact_os == 'windows' && '.zip' || '.tar.gz' }}
          path: mcp-artifact/

      - name: Extract mcp_server to target/release (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          ARCHIVE_NAME="${BINARY_NAME}-${{ steps.version.outputs.version }}-${{ matrix.artifact_os }}-${{ matrix.artifact_arch }}"
          tar xzf "mcp-artifact/${ARCHIVE_NAME}.tar.gz" -C mcp-artifact/
          mkdir -p target/release
          cp "mcp-artifact/${ARCHIVE_NAME}/mcp_server" target/release/mcp_server
          chmod +x target/release/mcp_server
          echo "✅ mcp_server extracted to target/release/"
          ls -la target/release/mcp_server

      - name: Extract mcp_server to target/release (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $archiveName = "${env:BINARY_NAME}-${version}-windows-${{ matrix.artifact_arch }}"
          Expand-Archive -Path "mcp-artifact/${archiveName}.zip" -DestinationPath "mcp-artifact/"
          New-Item -ItemType Directory -Force -Path "target/release"
          Copy-Item "mcp-artifact/${archiveName}/mcp_server.exe" "target/release/mcp_server.exe"
          # Tauri resource path expects "mcp_server" without .exe extension
          Copy-Item "target/release/mcp_server.exe" "target/release/mcp_server"
          Write-Host "✅ mcp_server extracted to target/release/"

      # --- macOS Code Signing: import certificate into a persistent keychain ---
      # We manage our own keychain so the certificate stays available for BOTH
      # the Tauri build step AND the post-build re-sign step (which adds --timestamp).
      # We do NOT pass APPLE_CERTIFICATE to Tauri — that would make Tauri create
      # its own temporary keychain, which gets cleaned up before re-sign runs.
      - name: Import Apple Developer certificate
        if: runner.os == 'macOS' && env.APPLE_CERTIFICATE != ''
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Create and configure keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          CERT_PATH=$RUNNER_TEMP/certificate.p12
          echo "$APPLE_CERTIFICATE" | base64 --decode > "$CERT_PATH"
          security import "$CERT_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Add to keychain search list (prepend so it's found first)
          security list-keychain -d user -s "$KEYCHAIN_PATH" $(security list-keychain -d user | tr -d '"')

          # Verify
          security find-identity -v "$KEYCHAIN_PATH"
          rm -f "$CERT_PATH"

      # IMPORTANT: TAURI_SIGNING_PRIVATE_KEY must be set in GitHub Secrets for
      # auto-update to work. Without it, Tauri won't generate the updater bundles
      # (.app.tar.gz, .AppImage.tar.gz, .nsis.zip) nor their .sig files, and
      # latest.json will have empty URLs — causing "relative URL without a base"
      # errors on the client.
      #
      # Generate a keypair with: cargo tauri signer generate -w ~/.tauri/myapp.key
      # Then set TAURI_SIGNING_PRIVATE_KEY to the contents of the private key file,
      # and update the pubkey in desktop/src-tauri/tauri.conf.json → plugins.updater.pubkey
      #
      # macOS: We pass APPLE_SIGNING_IDENTITY only (NOT APPLE_CERTIFICATE) so Tauri
      # uses our pre-imported keychain instead of creating its own temporary one.
      # This keeps the certificate available for the re-sign step that follows.
      - name: Build Tauri bundle
        working-directory: desktop/src-tauri
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          # macOS — identity only, certificate is in our persistent keychain
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          # Windows signing
          TAURI_WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          TAURI_WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: cargo tauri build --target ${{ matrix.tauri_target }}

      # --- macOS: Re-sign with --timestamp for notarization ---
      # Tauri's built-in codesign does NOT pass --timestamp to codesign (bug in
      # tauri-macos-sign). Apple requires a secure timestamp for notarization.
      # We re-sign everything after the Tauri build with --timestamp added.
      - name: Re-sign macOS bundle with timestamp
        if: runner.os == 'macOS' && env.APPLE_CERTIFICATE != ''
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          BUNDLE_DIR="desktop/src-tauri/target/${{ matrix.target }}/release/bundle"
          APP_PATH=$(find "$BUNDLE_DIR/macos" -name "*.app" -maxdepth 1 | head -1)

          if [ -z "$APP_PATH" ]; then
            echo "::warning::No .app bundle found — skipping re-sign"
            exit 0
          fi

          echo "Re-signing $APP_PATH with --timestamp..."

          # Sign deepest binaries first (inside-out order required by codesign)
          # 1. Sign all nested frameworks and dylibs
          find "$APP_PATH/Contents/Frameworks" -type f -perm +111 2>/dev/null | while read binary; do
            echo "  Signing framework: $(basename "$binary")"
            codesign --force --timestamp --options runtime \
              --sign "$APPLE_SIGNING_IDENTITY" "$binary" || true
          done

          # 2. Sign all nested executables (helpers, etc.)
          find "$APP_PATH/Contents/MacOS" -type f -perm +111 | while read binary; do
            echo "  Signing executable: $(basename "$binary")"
            codesign --force --timestamp --options runtime \
              --sign "$APPLE_SIGNING_IDENTITY" "$binary"
          done

          # 3. Sign the .app bundle itself (must be last)
          codesign --force --timestamp --options runtime \
            --sign "$APPLE_SIGNING_IDENTITY" "$APP_PATH"

          # 4. Verify the signature
          echo "Verifying signature..."
          codesign --verify --deep --strict "$APP_PATH"
          echo "✅ Re-sign with timestamp successful"

      # --- macOS: Rebuild updater bundles after re-sign ---
      # The .app.tar.gz and .sig generated by Tauri are now stale (different codesign).
      # Recreate them with the re-signed .app.
      - name: Rebuild updater bundles after re-sign
        if: runner.os == 'macOS' && env.APPLE_CERTIFICATE != ''
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          BUNDLE_DIR="desktop/src-tauri/target/${{ matrix.target }}/release/bundle"
          APP_PATH=$(find "$BUNDLE_DIR/macos" -name "*.app" -maxdepth 1 | head -1)
          APP_NAME=$(basename "$APP_PATH")

          if [ -z "$APP_PATH" ]; then
            echo "::warning::No .app bundle found — skipping updater rebuild"
            exit 0
          fi

          # Recreate .app.tar.gz
          TAR_PATH="$BUNDLE_DIR/macos/${APP_NAME}.tar.gz"
          echo "Recreating $TAR_PATH..."
          cd "$BUNDLE_DIR/macos"
          rm -f "$(basename "$TAR_PATH")" "$(basename "$TAR_PATH").sig"
          tar czf "$(basename "$TAR_PATH")" "$APP_NAME"
          cd -

          # Re-sign the .app.tar.gz with Tauri updater key
          echo "Signing updater bundle with Tauri key..."
          cargo tauri signer sign "$TAR_PATH" --private-key-path <(echo "$TAURI_SIGNING_PRIVATE_KEY") ${TAURI_SIGNING_PRIVATE_KEY_PASSWORD:+--password "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD"}
          echo "✅ Updater bundle recreated and signed"

          # Also re-sign the .dmg with timestamp
          DMG_PATH=$(find "$BUNDLE_DIR/dmg" -name "*.dmg" | head -1)
          if [ -n "$DMG_PATH" ]; then
            echo "Re-signing DMG with timestamp..."
            codesign --force --timestamp --sign "${{ secrets.APPLE_SIGNING_IDENTITY }}" "$DMG_PATH" || true
          fi

      # --- macOS Notarization: submit to Apple and staple ---
      - name: Notarize macOS .dmg
        if: runner.os == 'macOS' && env.APPLE_ID != ''
        continue-on-error: true
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          DMG_PATH=$(find desktop/src-tauri/target/${{ matrix.target }}/release/bundle/dmg -name "*.dmg" | head -1)
          if [ -n "$DMG_PATH" ]; then
            echo "Notarizing $DMG_PATH..."
            SUBMIT_OUTPUT=$(xcrun notarytool submit "$DMG_PATH" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait 2>&1) || true
            echo "$SUBMIT_OUTPUT"

            # Extract submission ID and fetch detailed log on failure
            SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep -oE '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' | head -1)
            if echo "$SUBMIT_OUTPUT" | grep -qi "invalid"; then
              echo "::error::Notarization returned Invalid — fetching Apple log..."
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" || true
            elif echo "$SUBMIT_OUTPUT" | grep -qi "accepted"; then
              echo "✅ Notarization accepted!"
              echo "Stapling notarization ticket..."
              xcrun stapler staple "$DMG_PATH"
              echo "Verifying..."
              spctl --assess --type open --context context:primary-signature -v "$DMG_PATH" || true
            fi
          fi

      - name: Upload Tauri artifacts (macOS)
        if: runner.os == 'macOS'
        uses: actions/upload-artifact@v4
        with:
          name: tauri-${{ matrix.target }}
          path: |
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/macos/*.app.tar.gz
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/macos/*.app.tar.gz.sig
          retention-days: 1

      - name: Upload Tauri artifacts (Linux)
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: tauri-${{ matrix.target }}
          path: |
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/deb/*.deb
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage.tar.gz
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage.tar.gz.sig
          retention-days: 1

      - name: Upload Tauri artifacts (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: tauri-${{ matrix.target }}
          path: |
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.exe
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.nsis.zip
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.nsis.zip.sig
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/msi/*.msi
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/msi/*.msi.zip
            desktop/src-tauri/target/${{ matrix.target }}/release/bundle/msi/*.msi.zip.sig
          retention-days: 1

      # --- macOS Cleanup: remove temp keychain ---
      - name: Cleanup macOS keychain
        if: runner.os == 'macOS' && always()
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true

  # ==========================================================================
  # Release - Collect all artifacts and publish GitHub Release
  # ==========================================================================
  release:
    name: Publish Release
    runs-on: ubuntu-latest
    needs: [build-backend, build-tauri, package-deb, package-rpm]
    # Always run: collect whatever artifacts succeeded.
    # Individual matrix entries may fail/cancel (e.g. macos-13 runner unavailable)
    # but we still want to publish everything that built successfully.
    if: always()
    steps:
      - uses: actions/checkout@v4

      - name: Download release artifacts (native builds)
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          pattern: orchestrator-*

      - name: Download release artifacts (deb/rpm)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          path: artifacts/
          pattern: project-orchestrator*

      - name: Download release artifacts (tauri)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          path: artifacts/
          pattern: tauri-*

      - name: Collect release files
        run: |
          mkdir -p release-files
          find artifacts/ -type f \( -name "*.tar.gz" -o -name "*.zip" -o -name "*.deb" -o -name "*.rpm" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.exe" -o -name "*.msi" -o -name "*.sig" \) -exec cp {} release-files/ \;
          echo "=== Release artifacts ==="
          ls -la release-files/ || echo "No release files found"

      - name: Generate checksums
        working-directory: release-files
        run: |
          sha256sum * > checksums-sha256.txt
          echo "=== Checksums ==="
          cat checksums-sha256.txt

      - name: Generate Tauri updater latest.json
        shell: bash
        run: |
          VERSION="${RELEASE_TAG#v}"
          REPO="${{ github.repository }}"
          BASE_URL="https://github.com/${REPO}/releases/download/${RELEASE_TAG}"
          NOTES=$(cat <<'EOFNOTES'
          See release notes at https://github.com/${REPO}/releases/tag/${RELEASE_TAG}
          EOFNOTES
          )
          PUB_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Read signatures from .sig files
          DARWIN_AARCH64_SIG=""
          DARWIN_X86_64_SIG=""
          LINUX_X86_64_SIG=""
          WINDOWS_X86_64_SIG=""

          # macOS signatures (.app.tar.gz.sig)
          for f in release-files/*aarch64-apple-darwin*.app.tar.gz.sig release-files/*aarch64*.app.tar.gz.sig; do
            [ -f "$f" ] && DARWIN_AARCH64_SIG=$(cat "$f") && break
          done
          for f in release-files/*x86_64-apple-darwin*.app.tar.gz.sig release-files/*x86_64*.app.tar.gz.sig; do
            [ -f "$f" ] && DARWIN_X86_64_SIG=$(cat "$f") && break
          done
          # Linux signatures (.AppImage.tar.gz.sig)
          for f in release-files/*x86_64*linux*.AppImage.tar.gz.sig; do
            [ -f "$f" ] && LINUX_X86_64_SIG=$(cat "$f") && break
          done
          # Windows signatures (.nsis.zip.sig)
          for f in release-files/*x86_64*windows*.nsis.zip.sig; do
            [ -f "$f" ] && WINDOWS_X86_64_SIG=$(cat "$f") && break
          done

          # Find the actual artifact filenames for URLs
          DARWIN_AARCH64_URL=""
          DARWIN_X86_64_URL=""
          LINUX_X86_64_URL=""
          WINDOWS_X86_64_URL=""

          for f in release-files/*aarch64-apple-darwin*.app.tar.gz; do
            [ -f "$f" ] && [[ "$f" != *.sig ]] && DARWIN_AARCH64_URL="${BASE_URL}/$(basename "$f")" && break
          done
          for f in release-files/*x86_64-apple-darwin*.app.tar.gz; do
            [ -f "$f" ] && [[ "$f" != *.sig ]] && DARWIN_X86_64_URL="${BASE_URL}/$(basename "$f")" && break
          done
          for f in release-files/*x86_64*linux*.AppImage.tar.gz; do
            [ -f "$f" ] && [[ "$f" != *.sig ]] && LINUX_X86_64_URL="${BASE_URL}/$(basename "$f")" && break
          done
          for f in release-files/*x86_64*windows*.nsis.zip; do
            [ -f "$f" ] && [[ "$f" != *.sig ]] && WINDOWS_X86_64_URL="${BASE_URL}/$(basename "$f")" && break
          done

          # Build JSON using jq
          jq -n \
            --arg version "$VERSION" \
            --arg notes "See full release notes on GitHub" \
            --arg pub_date "$PUB_DATE" \
            --arg darwin_aarch64_url "$DARWIN_AARCH64_URL" \
            --arg darwin_aarch64_sig "$DARWIN_AARCH64_SIG" \
            --arg darwin_x86_64_url "$DARWIN_X86_64_URL" \
            --arg darwin_x86_64_sig "$DARWIN_X86_64_SIG" \
            --arg linux_x86_64_url "$LINUX_X86_64_URL" \
            --arg linux_x86_64_sig "$LINUX_X86_64_SIG" \
            --arg windows_x86_64_url "$WINDOWS_X86_64_URL" \
            --arg windows_x86_64_sig "$WINDOWS_X86_64_SIG" \
            '{
              version: $version,
              notes: $notes,
              pub_date: $pub_date,
              platforms: {
                "darwin-aarch64": { url: $darwin_aarch64_url, signature: $darwin_aarch64_sig },
                "darwin-x86_64": { url: $darwin_x86_64_url, signature: $darwin_x86_64_sig },
                "linux-x86_64": { url: $linux_x86_64_url, signature: $linux_x86_64_sig },
                "windows-x86_64": { url: $windows_x86_64_url, signature: $windows_x86_64_sig }
              }
            }' > release-files/latest.json

          echo "=== Tauri updater latest.json ==="
          cat release-files/latest.json

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          generate_release_notes: true
          files: |
            release-files/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ==========================================================================
  # Docker - Build and push multi-arch images to ghcr.io
  # ==========================================================================
  docker-publish:
    name: Docker (${{ matrix.variant }})
    runs-on: ubuntu-latest
    needs: [build-frontend]
    strategy:
      fail-fast: false
      matrix:
        include:
          - variant: full
            include_frontend: "true"
            suffix: ""

          - variant: api-only
            include_frontend: "false"
            suffix: "-api"

    steps:
      - uses: actions/checkout@v4

      - name: Download frontend dist
        if: matrix.include_frontend == 'true'
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist/

      - name: Create empty frontend dir
        if: matrix.include_frontend == 'false'
        run: mkdir -p frontend/dist

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up QEMU (for multi-arch)
        uses: docker/setup-qemu-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          flavor: |
            suffix=${{ matrix.suffix }}
          tags: |
            type=raw,value=${{ env.RELEASE_TAG }}
            type=raw,value=latest,enable=${{ matrix.variant == 'full' }}
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          build-args: |
            FRONTEND_SRC=./frontend
            INCLUDE_FRONTEND=${{ matrix.include_frontend }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=release-docker
          cache-to: type=gha,mode=max,scope=release-docker

  # ==========================================================================
  # Update Homebrew tap - Push new formula after release is published
  # ==========================================================================
  update-homebrew:
    name: Update Homebrew Formula
    runs-on: ubuntu-latest
    needs: [release]
    # Skip pre-releases (e.g. v0.0.1-beta). Works for both tag push and workflow_dispatch.
    if: ${{ !contains(inputs.tag || github.ref_name, '-') }}
    steps:
      - uses: actions/checkout@v4

      - name: Get version from tag
        id: version
        run: echo "version=${RELEASE_TAG#v}" >> "$GITHUB_OUTPUT"

      - name: Download checksums
        run: |
          curl -fsSL "https://github.com/${{ github.repository }}/releases/download/${RELEASE_TAG}/checksums-sha256.txt" \
            -o checksums-sha256.txt
          cat checksums-sha256.txt

      - name: Extract SHA256 values
        id: sha
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          cat checksums-sha256.txt

          macos_arm64=$(grep "orchestrator-full-${VERSION}-macos-arm64.tar.gz" checksums-sha256.txt | awk '{print $1}' || true)
          macos_x86_64=$(grep "orchestrator-full-${VERSION}-macos-x86_64.tar.gz" checksums-sha256.txt | awk '{print $1}' || true)
          linux_arm64=$(grep "orchestrator-full-${VERSION}-linux-arm64.tar.gz" checksums-sha256.txt | awk '{print $1}' || true)
          linux_x86_64=$(grep "orchestrator-full-${VERSION}-linux-x86_64.tar.gz" checksums-sha256.txt | awk '{print $1}' || true)

          # Validate required checksums (at minimum: macOS ARM64 + Linux x86_64)
          if [ -z "$macos_arm64" ] || [ -z "$linux_x86_64" ]; then
            echo "::error::Missing required checksums (macos_arm64 or linux_x86_64)"
            exit 1
          fi

          # For missing optional platforms, reuse the same-OS alternative
          [ -z "$macos_x86_64" ] && macos_x86_64="$macos_arm64" && echo "::warning::macOS x86_64 not available, using ARM64 universal"
          [ -z "$linux_arm64" ] && linux_arm64="$linux_x86_64" && echo "::warning::Linux ARM64 not available, using x86_64"

          echo "macos_arm64=${macos_arm64}" >> "$GITHUB_OUTPUT"
          echo "macos_x86_64=${macos_x86_64}" >> "$GITHUB_OUTPUT"
          echo "linux_arm64=${linux_arm64}" >> "$GITHUB_OUTPUT"
          echo "linux_x86_64=${linux_x86_64}" >> "$GITHUB_OUTPUT"

      - name: Generate updated formula
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          sed -e "s/VERSION_PLACEHOLDER/${VERSION}/g" \
              -e "s/SHA256_MACOS_ARM64_PLACEHOLDER/${{ steps.sha.outputs.macos_arm64 }}/g" \
              -e "s/SHA256_MACOS_X86_64_PLACEHOLDER/${{ steps.sha.outputs.macos_x86_64 }}/g" \
              -e "s/SHA256_LINUX_ARM64_PLACEHOLDER/${{ steps.sha.outputs.linux_arm64 }}/g" \
              -e "s/SHA256_LINUX_X86_64_PLACEHOLDER/${{ steps.sha.outputs.linux_x86_64 }}/g" \
              packaging/homebrew/project-orchestrator.rb > formula.rb
          cat formula.rb

      - name: Push to Homebrew tap
        uses: dmnemec/copy_file_to_another_repo_action@main
        env:
          API_TOKEN_GITHUB: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        with:
          source_file: formula.rb
          destination_repo: this-rs/homebrew-tap
          destination_folder: Formula
          destination_branch_create: main
          destination_file: project-orchestrator.rb
          user_email: "t@ffs.holdings"
          user_name: "Théotime Rivière"
          commit_message: "Update project-orchestrator to v${{ steps.version.outputs.version }}"
