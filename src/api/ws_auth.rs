//! WebSocket authentication — cookie-based (pre-upgrade) with ticket fallback.
//!
//! For browser clients that send the `refresh_token` cookie automatically:
//! 1. Extract the `refresh_token` cookie from the HTTP upgrade headers
//! 2. Validate the token hash in the database (non-expired, non-revoked)
//! 3. Look up the user to build Claims
//! 4. Accept the WebSocket upgrade → send `auth_ok` immediately
//!
//! For clients where cookies are NOT sent on WebSocket upgrades (e.g. WKWebView
//! in Tauri desktop apps — a known WebKit limitation where NSURLSession-based
//! WebSockets don't share the HTTP cookie jar):
//! 1. Client fetches `POST /auth/ws-ticket` (via `fetch()` which sends cookies)
//! 2. Server returns a short-lived, single-use ticket
//! 3. Client passes `?ticket=xxx` in the WebSocket URL
//! 4. Server validates the ticket BEFORE the upgrade
//!
//! Authentication happens BEFORE the upgrade, so invalid credentials result
//! in a 401 HTTP response (no WS connection opened).
//!
//! In no-auth mode, anonymous Claims are returned immediately.

use crate::auth::jwt::Claims;
use crate::auth::refresh;
use crate::neo4j::GraphStore;
use crate::AuthConfig;
use axum::extract::ws::{Message, WebSocket};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::Instant;
use tracing::{debug, warn};
use uuid::Uuid;

// ============================================================================
// WS Ticket Store
// ============================================================================

/// How long a WS ticket remains valid (seconds).
const TICKET_TTL_SECS: u64 = 30;

/// A pending WebSocket ticket — single-use, short-lived.
struct WsTicket {
    claims: Claims,
    created_at: Instant,
}

/// In-memory store for ephemeral WebSocket auth tickets.
///
/// Tickets are generated by `POST /auth/ws-ticket` (which validates the
/// HttpOnly cookie via `fetch()`) and consumed during the WS upgrade
/// handshake. Each ticket is single-use and expires after [`TICKET_TTL_SECS`].
///
/// This works around WKWebView (macOS/iOS) not sending cookies on WebSocket
/// upgrade requests — a known WebKit limitation since macOS Monterey.
#[derive(Default)]
pub struct WsTicketStore {
    tickets: RwLock<HashMap<String, WsTicket>>,
}

impl WsTicketStore {
    /// Create an empty ticket store.
    pub fn new() -> Self {
        Self {
            tickets: RwLock::new(HashMap::new()),
        }
    }

    /// Generate a new ticket for the given claims. Returns the ticket string.
    pub async fn create_ticket(&self, claims: Claims) -> String {
        let ticket = Uuid::new_v4().to_string();
        let entry = WsTicket {
            claims,
            created_at: Instant::now(),
        };
        self.tickets.write().await.insert(ticket.clone(), entry);
        ticket
    }

    /// Consume a ticket — returns the Claims if valid, None if missing/expired.
    ///
    /// The ticket is removed from the store regardless (single-use).
    pub async fn consume_ticket(&self, ticket: &str) -> Option<Claims> {
        let entry = self.tickets.write().await.remove(ticket)?;
        if entry.created_at.elapsed().as_secs() > TICKET_TTL_SECS {
            debug!(
                "WS ticket expired (age {}s)",
                entry.created_at.elapsed().as_secs()
            );
            return None;
        }
        Some(entry.claims)
    }

    /// Remove all expired tickets. Called periodically by a background task.
    pub async fn cleanup_expired(&self) {
        let mut map = self.tickets.write().await;
        let before = map.len();
        map.retain(|_, t| t.created_at.elapsed().as_secs() <= TICKET_TTL_SECS);
        let removed = before - map.len();
        if removed > 0 {
            debug!("WS ticket cleanup: removed {} expired tickets", removed);
        }
    }
}

// ============================================================================
// Cookie auth result
// ============================================================================

/// Result of pre-upgrade authentication (cookie or ticket).
///
/// Used by WebSocket upgrade handlers to decide whether to accept the upgrade:
/// - `Authenticated(Claims)` → cookie/ticket valid (or no-auth mode), upgrade and send `auth_ok`
/// - `Invalid(String)` → no cookie/ticket or invalid, reject with 401
#[derive(Debug)]
pub enum CookieAuthResult {
    /// Cookie or ticket was valid — upgrade the connection
    Authenticated(Claims),
    /// No valid credentials — reject the upgrade with 401
    Invalid(String),
}

/// Authenticate a WebSocket upgrade request via cookie or ticket.
///
/// This is called BEFORE the WebSocket upgrade to validate credentials.
/// The result tells the caller whether to accept or reject the upgrade.
///
/// # Auth priority
/// 1. If `auth_config` is `None` → **no-auth mode**: return `Authenticated` with anonymous Claims
/// 2. Try **cookie** first (normal browser path) — validate `refresh_token` in DB
/// 3. If no cookie → try **ticket** (Tauri/WKWebView fallback) — consume from `WsTicketStore`
/// 4. If neither → return `Invalid` (reject with 401)
pub async fn ws_authenticate(
    headers: &axum::http::HeaderMap,
    auth_config: &Option<AuthConfig>,
    neo4j: &Arc<dyn GraphStore>,
    ticket: Option<&str>,
    ticket_store: &Arc<WsTicketStore>,
) -> CookieAuthResult {
    // 1. No-auth mode → anonymous access
    let config = match auth_config {
        Some(c) => c,
        None => {
            debug!("WS auth: no-auth mode → anonymous");
            return CookieAuthResult::Authenticated(Claims::anonymous());
        }
    };

    // 2. Try cookie first (primary path — works in normal browsers)
    let cookie_result = try_cookie_auth(headers, config, neo4j).await;
    if let Some(result) = cookie_result {
        return result;
    }

    // 3. No cookie → try ticket fallback (Tauri/WKWebView workaround)
    if let Some(ticket_value) = ticket {
        debug!("WS auth: no cookie, trying ticket fallback");
        if let Some(claims) = ticket_store.consume_ticket(ticket_value).await {
            debug!(email = %claims.email, "WS auth: authenticated via ticket");
            return CookieAuthResult::Authenticated(claims);
        }
        warn!("WS auth: ticket invalid or expired");
        return CookieAuthResult::Invalid("Invalid or expired ticket".to_string());
    }

    // 4. Neither cookie nor ticket
    debug!("WS auth: no cookie and no ticket → rejecting");
    CookieAuthResult::Invalid("No refresh_token cookie or ticket".to_string())
}

/// Try to authenticate via the `refresh_token` cookie.
///
/// Returns `Some(CookieAuthResult)` if a cookie was found (valid or not),
/// or `None` if no cookie was present (caller should try ticket fallback).
async fn try_cookie_auth(
    headers: &axum::http::HeaderMap,
    config: &AuthConfig,
    neo4j: &Arc<dyn GraphStore>,
) -> Option<CookieAuthResult> {
    // Extract cookie from HTTP headers
    let cookie_header = headers
        .get(axum::http::header::COOKIE)
        .and_then(|v| v.to_str().ok())?;

    let raw_token = refresh::extract_refresh_token_from_cookie(cookie_header)?;

    // Validate the refresh token in DB (checks expiry + revoked)
    let token_hash = refresh::hash_token(&raw_token);
    let token_node = match neo4j.validate_refresh_token(&token_hash).await {
        Ok(Some(node)) => node,
        Ok(None) => {
            warn!("WS cookie auth: invalid or expired refresh token");
            return Some(CookieAuthResult::Invalid(
                "Invalid or expired refresh token".to_string(),
            ));
        }
        Err(e) => {
            warn!("WS cookie auth: DB error validating token: {}", e);
            return Some(CookieAuthResult::Invalid(format!(
                "Token validation error: {}",
                e
            )));
        }
    };

    // Look up user info to build Claims
    let (user_id, email, name) = match neo4j.get_user_by_id(token_node.user_id).await {
        Ok(Some(user)) => (user.id, user.email, user.name),
        Ok(None) => {
            // Root account fallback — root users are not stored in Neo4j
            if let Some(ref root) = config.root_account {
                let root_id = Uuid::new_v5(&Uuid::NAMESPACE_URL, root.email.as_bytes());
                if root_id == token_node.user_id {
                    (root_id, root.email.clone(), root.name.clone())
                } else {
                    warn!("WS cookie auth: user not found for token");
                    return Some(CookieAuthResult::Invalid("User not found".to_string()));
                }
            } else {
                warn!("WS cookie auth: user not found for token");
                return Some(CookieAuthResult::Invalid("User not found".to_string()));
            }
        }
        Err(e) => {
            warn!("WS cookie auth: DB error looking up user: {}", e);
            return Some(CookieAuthResult::Invalid(format!(
                "User lookup error: {}",
                e
            )));
        }
    };

    // Build Claims
    let now = chrono::Utc::now().timestamp();
    let claims = Claims {
        sub: user_id.to_string(),
        email: email.clone(),
        name: name.clone(),
        iat: now,
        exp: now + config.access_token_expiry_secs as i64,
    };

    debug!(email = %email, "WS auth: authenticated via refresh_token cookie");
    Some(CookieAuthResult::Authenticated(claims))
}

/// Send an `auth_ok` message with user info through the WebSocket.
///
/// Called after upgrade when authentication was done pre-upgrade (cookie).
pub async fn send_auth_ok(socket: &mut WebSocket, claims: &Claims) {
    let auth_ok = serde_json::json!({
        "type": "auth_ok",
        "user": {
            "id": claims.sub,
            "email": claims.email,
            "name": claims.name,
        }
    });
    let _ = socket.send(Message::Text(auth_ok.to_string().into())).await;
}

// ============================================================================
// Ready handshake — logic + WS wrapper
// ============================================================================

/// Timeout for the client to send "ready" before we fall back.
const READY_TIMEOUT_SECS: u64 = 5;

/// Result of classifying a single WebSocket message during the ready handshake.
#[derive(Debug, PartialEq)]
pub(crate) enum ReadyCheck {
    /// Client sent "ready" — proceed with auth_ok
    Ready,
    /// Ignorable message (Ping, Pong, unrelated text) — keep waiting
    Continue,
    /// Client disconnected or error — abort
    Disconnected,
}

/// Classify a WebSocket message for the ready handshake.
///
/// Accepts both JSON `"ready"` (quoted string) and bare `ready`.
pub(crate) fn classify_ready_message(msg: &Result<Message, axum::Error>) -> ReadyCheck {
    match msg {
        Ok(Message::Text(text)) => {
            let trimmed = text.trim().trim_matches('"');
            if trimmed == "ready" || text.contains("\"ready\"") {
                ReadyCheck::Ready
            } else {
                ReadyCheck::Continue
            }
        }
        Ok(Message::Ping(_)) | Ok(Message::Pong(_)) => ReadyCheck::Continue,
        Ok(Message::Close(_)) => ReadyCheck::Disconnected,
        Err(_) => ReadyCheck::Disconnected,
        _ => ReadyCheck::Continue,
    }
}

/// Wait for the client to send a `"ready"` message, then send `auth_ok`.
///
/// This handshake prevents a race condition with the Tauri WebSocket plugin
/// where `auth_ok` would be lost if sent before the client's message listener
/// is registered (the plugin's `connect()` resolves before `addListener()`).
///
/// If the client doesn't send `"ready"` within [`READY_TIMEOUT_SECS`],
/// `auth_ok` is sent anyway as a fallback for older clients.
pub async fn wait_ready_then_auth_ok(socket: &mut WebSocket, claims: &Claims) {
    use futures::StreamExt;
    use tokio::time::{timeout, Duration};

    let wait = timeout(Duration::from_secs(READY_TIMEOUT_SECS), async {
        while let Some(msg) = socket.next().await {
            match classify_ready_message(&msg) {
                ReadyCheck::Ready => {
                    debug!("WS: received 'ready' from client");
                    return true;
                }
                ReadyCheck::Disconnected => return false,
                ReadyCheck::Continue => continue,
            }
        }
        false
    });

    match wait.await {
        Ok(true) => {
            // Client sent "ready" — send auth_ok
            send_auth_ok(socket, claims).await;
        }
        Ok(false) => {
            // Client disconnected before sending ready
            debug!("WS: client disconnected before sending ready, skipping auth_ok");
        }
        Err(_) => {
            // Timeout — send auth_ok anyway (fallback for older clients)
            warn!("WS: client did not send 'ready' within 5s, sending auth_ok anyway");
            send_auth_ok(socket, claims).await;
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::neo4j::mock::MockGraphStore;
    use crate::test_helpers::test_auth_config;
    use axum::http::HeaderMap;

    /// Convenience: empty ticket store for cookie-only tests.
    fn empty_store() -> Arc<WsTicketStore> {
        Arc::new(WsTicketStore::new())
    }

    /// Create a mock Neo4j with a user and a valid refresh token.
    /// Returns (mock, user_id, raw_token).
    async fn setup_mock_with_user_and_token() -> (Arc<MockGraphStore>, Uuid, String) {
        let mock = Arc::new(MockGraphStore::new());

        // Create a user via create_password_user
        let user = mock
            .create_password_user("alice@ffs.holdings", "Alice", "hash")
            .await
            .unwrap();
        let user_id = user.id;

        // Create a refresh token
        let raw_token = refresh::generate_token();
        let token_hash = refresh::hash_token(&raw_token);
        let expires_at = chrono::Utc::now() + chrono::Duration::hours(24);
        mock.create_refresh_token(user_id, &token_hash, expires_at)
            .await
            .unwrap();

        (mock, user_id, raw_token)
    }

    /// Build a HeaderMap with a Cookie header containing the refresh_token.
    fn headers_with_cookie(raw_token: &str) -> HeaderMap {
        let mut headers = HeaderMap::new();
        headers.insert(
            axum::http::header::COOKIE,
            format!("refresh_token={}", raw_token).parse().unwrap(),
        );
        headers
    }

    // ========================================================================
    // WsTicketStore tests
    // ========================================================================

    #[tokio::test]
    async fn test_ticket_store_create_and_consume() {
        let store = WsTicketStore::new();
        let claims = Claims::anonymous();
        let ticket = store.create_ticket(claims).await;

        let result = store.consume_ticket(&ticket).await;
        assert!(result.is_some(), "First consume should return claims");
        assert_eq!(result.unwrap().email, "anonymous@local");
    }

    #[tokio::test]
    async fn test_ticket_store_single_use() {
        let store = WsTicketStore::new();
        let claims = Claims::anonymous();
        let ticket = store.create_ticket(claims).await;

        let first = store.consume_ticket(&ticket).await;
        assert!(first.is_some());

        let second = store.consume_ticket(&ticket).await;
        assert!(
            second.is_none(),
            "Second consume should return None (single-use)"
        );
    }

    #[tokio::test]
    async fn test_ticket_store_nonexistent_ticket() {
        let store = WsTicketStore::new();
        let result = store.consume_ticket("nonexistent").await;
        assert!(result.is_none());
    }

    #[tokio::test]
    async fn test_ticket_store_cleanup() {
        let store = WsTicketStore::new();
        let claims = Claims::anonymous();

        // Insert a ticket with a backdated created_at (expired)
        {
            let mut map = store.tickets.write().await;
            map.insert(
                "expired-ticket".to_string(),
                WsTicket {
                    claims,
                    created_at: Instant::now()
                        - std::time::Duration::from_secs(TICKET_TTL_SECS + 10),
                },
            );
        }

        assert_eq!(store.tickets.read().await.len(), 1);
        store.cleanup_expired().await;
        assert_eq!(store.tickets.read().await.len(), 0);
    }

    // ========================================================================
    // ws_authenticate — cookie path tests (regression)
    // ========================================================================

    #[tokio::test]
    async fn test_cookie_auth_no_auth_mode_returns_anonymous() {
        let mock = Arc::new(MockGraphStore::new());
        let headers = HeaderMap::new();
        let store = empty_store();

        let result = ws_authenticate(
            &headers,
            &None,
            &(mock as Arc<dyn GraphStore>),
            None,
            &store,
        )
        .await;

        match result {
            CookieAuthResult::Authenticated(claims) => {
                assert_eq!(claims.email, "anonymous@local");
                assert_eq!(claims.name, "Anonymous");
            }
            other => panic!("Expected Authenticated, got {:?}", other),
        }
    }

    #[tokio::test]
    async fn test_cookie_auth_no_cookie_no_ticket_returns_invalid() {
        let mock = Arc::new(MockGraphStore::new());
        let headers = HeaderMap::new();
        let config = Some(test_auth_config());
        let store = empty_store();

        let result = ws_authenticate(
            &headers,
            &config,
            &(mock as Arc<dyn GraphStore>),
            None,
            &store,
        )
        .await;

        match result {
            CookieAuthResult::Invalid(reason) => {
                assert!(
                    reason.contains("No refresh_token cookie or ticket"),
                    "Got: {}",
                    reason
                );
            }
            other => panic!("Expected Invalid, got {:?}", other),
        }
    }

    #[tokio::test]
    async fn test_cookie_auth_no_refresh_token_in_cookie_returns_invalid() {
        let mock = Arc::new(MockGraphStore::new());
        let mut headers = HeaderMap::new();
        headers.insert(
            axum::http::header::COOKIE,
            "session=abc123; other=xyz".parse().unwrap(),
        );
        let config = Some(test_auth_config());
        let store = empty_store();

        // Cookie header present but no refresh_token → falls through to ticket
        // No ticket either → Invalid
        let result = ws_authenticate(
            &headers,
            &config,
            &(mock as Arc<dyn GraphStore>),
            None,
            &store,
        )
        .await;

        match result {
            CookieAuthResult::Invalid(reason) => {
                assert!(
                    reason.contains("No refresh_token cookie or ticket"),
                    "Got: {}",
                    reason
                );
            }
            other => panic!("Expected Invalid, got {:?}", other),
        }
    }

    #[tokio::test]
    async fn test_cookie_auth_valid_token_returns_claims() {
        let (mock, user_id, raw_token) = setup_mock_with_user_and_token().await;
        let headers = headers_with_cookie(&raw_token);
        let config = Some(test_auth_config());
        let store = empty_store();

        let result = ws_authenticate(
            &headers,
            &config,
            &(mock as Arc<dyn GraphStore>),
            None,
            &store,
        )
        .await;

        match result {
            CookieAuthResult::Authenticated(claims) => {
                assert_eq!(claims.sub, user_id.to_string());
                assert_eq!(claims.email, "alice@ffs.holdings");
                assert_eq!(claims.name, "Alice");
            }
            other => panic!("Expected Authenticated, got {:?}", other),
        }
    }

    #[tokio::test]
    async fn test_cookie_auth_invalid_token_returns_invalid() {
        let mock = Arc::new(MockGraphStore::new());
        let headers = headers_with_cookie("nonexistent_token_value");
        let config = Some(test_auth_config());
        let store = empty_store();

        let result = ws_authenticate(
            &headers,
            &config,
            &(mock as Arc<dyn GraphStore>),
            None,
            &store,
        )
        .await;

        match result {
            CookieAuthResult::Invalid(reason) => {
                assert!(reason.contains("Invalid or expired"), "Got: {}", reason);
            }
            other => panic!("Expected Invalid, got {:?}", other),
        }
    }

    #[tokio::test]
    async fn test_cookie_auth_revoked_token_returns_invalid() {
        let (mock, _user_id, raw_token) = setup_mock_with_user_and_token().await;
        // Revoke the token
        let token_hash = refresh::hash_token(&raw_token);
        mock.revoke_refresh_token(&token_hash).await.unwrap();

        let headers = headers_with_cookie(&raw_token);
        let config = Some(test_auth_config());
        let store = empty_store();

        let result = ws_authenticate(
            &headers,
            &config,
            &(mock as Arc<dyn GraphStore>),
            None,
            &store,
        )
        .await;

        match result {
            CookieAuthResult::Invalid(reason) => {
                assert!(reason.contains("Invalid or expired"), "Got: {}", reason);
            }
            other => panic!("Expected Invalid, got {:?}", other),
        }
    }

    #[tokio::test]
    async fn test_cookie_auth_root_account_fallback() {
        let mock = Arc::new(MockGraphStore::new());

        // Create a root account config
        let mut config = test_auth_config();
        config.root_account = Some(crate::RootAccountConfig {
            email: "root@ffs.holdings".to_string(),
            name: "Root Admin".to_string(),
            password_hash: "hash".to_string(),
        });
        let root_id = Uuid::new_v5(&Uuid::NAMESPACE_URL, b"root@ffs.holdings");

        // Create a refresh token for root user (no UserNode in DB)
        let raw_token = refresh::generate_token();
        let token_hash = refresh::hash_token(&raw_token);
        let expires_at = chrono::Utc::now() + chrono::Duration::hours(24);
        mock.create_refresh_token(root_id, &token_hash, expires_at)
            .await
            .unwrap();

        let headers = headers_with_cookie(&raw_token);
        let store = empty_store();

        let result = ws_authenticate(
            &headers,
            &Some(config),
            &(mock as Arc<dyn GraphStore>),
            None,
            &store,
        )
        .await;

        match result {
            CookieAuthResult::Authenticated(claims) => {
                assert_eq!(claims.sub, root_id.to_string());
                assert_eq!(claims.email, "root@ffs.holdings");
                assert_eq!(claims.name, "Root Admin");
            }
            other => panic!("Expected Authenticated, got {:?}", other),
        }
    }

    // ========================================================================
    // ws_authenticate — ticket path tests
    // ========================================================================

    #[tokio::test]
    async fn test_ticket_auth_valid_ticket_returns_claims() {
        let mock = Arc::new(MockGraphStore::new());
        let headers = HeaderMap::new(); // no cookie
        let config = Some(test_auth_config());
        let store = Arc::new(WsTicketStore::new());

        // Create a ticket
        let claims = Claims {
            sub: "user-123".to_string(),
            email: "alice@ffs.holdings".to_string(),
            name: "Alice".to_string(),
            iat: 0,
            exp: i64::MAX,
        };
        let ticket = store.create_ticket(claims).await;

        let result = ws_authenticate(
            &headers,
            &config,
            &(mock as Arc<dyn GraphStore>),
            Some(&ticket),
            &store,
        )
        .await;

        match result {
            CookieAuthResult::Authenticated(claims) => {
                assert_eq!(claims.email, "alice@ffs.holdings");
                assert_eq!(claims.sub, "user-123");
            }
            other => panic!("Expected Authenticated, got {:?}", other),
        }
    }

    #[tokio::test]
    async fn test_ticket_auth_consumed_ticket_returns_invalid() {
        let mock = Arc::new(MockGraphStore::new());
        let headers = HeaderMap::new();
        let config = Some(test_auth_config());
        let store = Arc::new(WsTicketStore::new());

        let ticket = store.create_ticket(Claims::anonymous()).await;
        // Consume it once
        store.consume_ticket(&ticket).await;

        let result = ws_authenticate(
            &headers,
            &config,
            &(mock as Arc<dyn GraphStore>),
            Some(&ticket),
            &store,
        )
        .await;

        match result {
            CookieAuthResult::Invalid(reason) => {
                assert!(
                    reason.contains("Invalid or expired ticket"),
                    "Got: {}",
                    reason
                );
            }
            other => panic!("Expected Invalid, got {:?}", other),
        }
    }

    #[tokio::test]
    async fn test_ticket_auth_expired_ticket_returns_invalid() {
        let mock = Arc::new(MockGraphStore::new());
        let headers = HeaderMap::new();
        let config = Some(test_auth_config());
        let store = Arc::new(WsTicketStore::new());

        // Insert an expired ticket directly
        {
            let mut map = store.tickets.write().await;
            map.insert(
                "expired-ticket".to_string(),
                WsTicket {
                    claims: Claims::anonymous(),
                    created_at: Instant::now()
                        - std::time::Duration::from_secs(TICKET_TTL_SECS + 10),
                },
            );
        }

        let result = ws_authenticate(
            &headers,
            &config,
            &(mock as Arc<dyn GraphStore>),
            Some("expired-ticket"),
            &store,
        )
        .await;

        match result {
            CookieAuthResult::Invalid(reason) => {
                assert!(
                    reason.contains("Invalid or expired ticket"),
                    "Got: {}",
                    reason
                );
            }
            other => panic!("Expected Invalid, got {:?}", other),
        }
    }

    #[tokio::test]
    async fn test_ticket_auth_cookie_takes_priority_over_ticket() {
        let (mock, user_id, raw_token) = setup_mock_with_user_and_token().await;
        let headers = headers_with_cookie(&raw_token);
        let config = Some(test_auth_config());
        let store = Arc::new(WsTicketStore::new());

        // Create a ticket with different claims
        let ticket_claims = Claims {
            sub: "ticket-user".to_string(),
            email: "ticket@ffs.holdings".to_string(),
            name: "Ticket".to_string(),
            iat: 0,
            exp: i64::MAX,
        };
        let ticket = store.create_ticket(ticket_claims).await;

        // Should use cookie (priority), not ticket
        let result = ws_authenticate(
            &headers,
            &config,
            &(mock as Arc<dyn GraphStore>),
            Some(&ticket),
            &store,
        )
        .await;

        match result {
            CookieAuthResult::Authenticated(claims) => {
                assert_eq!(claims.sub, user_id.to_string());
                assert_eq!(claims.email, "alice@ffs.holdings");
            }
            other => panic!("Expected Authenticated via cookie, got {:?}", other),
        }
    }

    // ========================================================================
    // classify_ready_message tests
    // ========================================================================

    #[test]
    fn test_ready_bare_string() {
        let msg = Ok(Message::Text("ready".into()));
        assert_eq!(classify_ready_message(&msg), ReadyCheck::Ready);
    }

    #[test]
    fn test_ready_json_quoted() {
        let msg = Ok(Message::Text("\"ready\"".into()));
        assert_eq!(classify_ready_message(&msg), ReadyCheck::Ready);
    }

    #[test]
    fn test_ready_json_object() {
        let msg = Ok(Message::Text("{\"type\":\"ready\"}".into()));
        assert_eq!(classify_ready_message(&msg), ReadyCheck::Ready);
    }

    #[test]
    fn test_ready_with_whitespace() {
        let msg = Ok(Message::Text("  ready  ".into()));
        assert_eq!(classify_ready_message(&msg), ReadyCheck::Ready);
    }

    #[test]
    fn test_unrelated_text_returns_continue() {
        let msg = Ok(Message::Text("hello".into()));
        assert_eq!(classify_ready_message(&msg), ReadyCheck::Continue);
    }

    #[test]
    fn test_ping_returns_continue() {
        let msg = Ok(Message::Ping(vec![].into()));
        assert_eq!(classify_ready_message(&msg), ReadyCheck::Continue);
    }

    #[test]
    fn test_pong_returns_continue() {
        let msg = Ok(Message::Pong(vec![].into()));
        assert_eq!(classify_ready_message(&msg), ReadyCheck::Continue);
    }

    #[test]
    fn test_close_returns_disconnected() {
        let msg = Ok(Message::Close(None));
        assert_eq!(classify_ready_message(&msg), ReadyCheck::Disconnected);
    }

    #[test]
    fn test_error_returns_disconnected() {
        let msg: Result<Message, axum::Error> =
            Err(axum::Error::new(std::io::Error::other("test")));
        assert_eq!(classify_ready_message(&msg), ReadyCheck::Disconnected);
    }

    #[test]
    fn test_binary_returns_continue() {
        let msg = Ok(Message::Binary(vec![1, 2, 3].into()));
        assert_eq!(classify_ready_message(&msg), ReadyCheck::Continue);
    }

    #[test]
    fn test_ready_timeout_constant() {
        assert_eq!(READY_TIMEOUT_SECS, 5);
    }
}
